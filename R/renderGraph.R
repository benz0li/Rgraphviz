## Wrapper around paste for simple yet flexible namespacing of the attribute
## names. Is set to do nothing for now
myAtt <- function(att) att


## Mechanism to draw render information from a graph or from the
## defaults if not specified in the graph. The hierarchy is:
##   1. graph package defaults as set by graph.par
##   2. graph object defaults set by parRenderInfo in the renderInfo@pars slot
##   3. node or edge specific settings set by edgeRenderInfo or nodeRenderInfo
##      in slots renderInfo@edges and renderInfo@nodes
getRenderPar <-
    function(g, name, what = c("nodes", "edges", "graph"))
{
    what <- match.arg(what)
    nms <- switch(what, nodes = nodes(g), edges = edgeNames(g),
                  graph="graph") #FIXME: Deal with graph names 
    ans <- switch(what,
                  nodes = nodeRenderInfo(g, name), 
                  edges = edgeRenderInfo(g, name),
                  graph = graphRenderInfo(g, name))
    if (!is.null(ans) && !any(is.na(ans)))
        if(!is.null(names(ans)))
            ans[nms]
        else
            ans
    else
    {
        default <- parRenderInfo(g, what)[[name]][1]
        if (is.null(default)) default <- graph.par.get(what)[[name]][1]
        if (is.null(ans)) rep(default, length(nms))
        else
        {
            if(!is.null(default))
                ans[is.na(ans)] <- default
            ans[nms]
        }
    }
}



## This function will plot individual nodes on the plotting device.
## Update: This is now in a vectorized form (user can still
## supply a function, but that has to deal with vectorized data for now)
renderNodes <- function(g) 
{
    ## get necessary render parameters from the graph or use defaults
    ## these are generated by the layout algorithm
    nodeX <- getRenderPar(g, "nodeX", "nodes")
    nodeY <- getRenderPar(g, "nodeY", "nodes")
    lw <- getRenderPar(g, "lWidth", "nodes")
    rw <- getRenderPar(g, "rWidth", "nodes")
    height <- getRenderPar(g, "height", "nodes")
    rad    <- (lw+rw)/2
    labelX <- getRenderPar(g, "labelX", "nodes")
    labelY <- getRenderPar(g, "labelY", "nodes")
    #labelJust <- getRenderPar(g, "labelJust", "nodes") ## FIXME: do we need this
    #labelJust <- as.numeric(gsub("l", 0, gsub("n", -0.5, gsub("r", -1,
    #                        labelJust))))
    ## these only live within R
    fill <- getRenderPar(g, "fill", "nodes")
    col <- getRenderPar(g, "col", "nodes")
    textCol <- getRenderPar(g, "textCol", "nodes")
    style <- getRenderPar(g, "style", "nodes")
    shape <- getRenderPar(g, "shape", "nodes")
    label <- getRenderPar(g, "label", "nodes")
    fontsize <- getRenderPar(g, "fontsize", "nodes")
    if (is.null(label)) label <- nodes(g)
   

    ## deal with different shapes
    possible.shapes <-
        c("circle", "ellipse", "box", "rectangle", "plaintext")
    shape <-
        possible.shapes[pmatch(shape,
                               possible.shapes,
                               duplicates.ok = TRUE)]
    ## shape == circle
    i <- shape == "circle"
    if (any(i, na.rm=TRUE))
    {
        symbols(nodeX[i], nodeY[i], circles = rad[i],
                fg = col[i], bg = fill[i],
                inches = FALSE, add = TRUE)
    }
    ## shape == box, rect, etc
    i <- shape %in% c("box", "rectangle")
    if (any(i, na.rm=TRUE))
    {
        rect(nodeX[i] - lw[i], nodeY[i] - (height[i] / 2),
             nodeX[i] + rw[i], nodeY[i] + (height[i] / 2),
             col = fill[i], border = col[i])
    }
    ## shape == ellipse
    i <- shape == "ellipse"
    if (any(i, na.rm=TRUE))
    {
        npoints <- 51
        tt <- c(seq(-pi, pi, length = npoints), NA)
        xx <-
            rep(nodeX[i], each = npoints + 1) +
                sin(tt) * rep(rad[i], each = npoints + 1)
        yy <-
            rep(nodeY[i], each = npoints + 1) +
                cos(tt) * rep(height[i] / 2, each = npoints + 1)
        polygon(xx, yy, border = col[i], col = fill[i])
    }

    ## shape == plaintext
    ## nothing to do (for style = "filled", use fill = "grey")

    ## compute label cex from node dimensions if not set
    cex <- getRenderPar(g, "cex", "nodes")
    if(is.null(cex)){
        nodeDims <- cbind(lw+rw, height)
        strDims  <- cbind(strwidth(label)*1.1, strheight(label)*1.4)
        strDims[!nzchar(label),] <- c(strwidth(" "), strheight(" "))
        cex <- min(nodeDims / strDims)
    }
    
    ## draw labels
    text(labelX, labelY, label, col=textCol,
         cex=cex*as.numeric(fontsize)/14)
}



## A vectorized function that draws the splines for the edges
renderSpline <-
    function(spline, head = FALSE, tail = FALSE, len = 1,
             col = "black", lwd=1, lty="solid", ...)
{
    lapply(spline, lines, col = col, lwd=lwd, lty=lty, ...)
    if (head)
    {
        xy <- tail(bezierPoints(spline[[length(spline)]]), 2)
        arrows(xy[1], xy[3], xy[2], xy[4], length = len, col = col,
               lwd=lwd, lty=lty)
    }
    if (tail)
    {
        xy <- head(bezierPoints(spline[[1]]), 2)
        arrows(xy[2], xy[4], xy[1], xy[3], length = len, col = col,
               lwd=lwd, lty=lty)
    }
}



## This function will plot individual edges on the plotting device.
renderEdges <- function(g)
{
    ## get necessary render parameters
    ## these are generated by the layout algorithm
    lw <- getRenderPar(g, "lWidth", "nodes")
    rw <- getRenderPar(g, "rWidth", "nodes")
    height <- getRenderPar(g, "height", "nodes")
    splines <- getRenderPar(g, "splines", "edges")
    ## direction <- getRenderPar(g, "direction", "edges") ## UNUSED (isn't this redundant?)
    arrowhead <- getRenderPar(g, "arrowhead", "edges") != "none"
    arrowtail <- getRenderPar(g, "arrowtail", "edges") != "none"
    label <- getRenderPar(g, "label", "edges")
    labelX <- getRenderPar(g, "labelX", "edges")
    labelY  <- getRenderPar(g, "labelY", "edges")
    #labelJust <- getRenderPar(g, "labelJust", "edges") ## FIXME: do we need this
    #labelJust <- as.numeric(gsub("l", 0, gsub("n", -0.5, gsub("r", -1,
    #                        labelJust))))              
    #labelWidth <- getRenderPar(g, "labelWidth", "edges") ## FIXME: do we need this?
    ## these only live within R
    fontsize <- getRenderPar(g, "fontsize", "edges")
    textCol <- getRenderPar(g, "textCol", "edges")
    col <- getRenderPar(g, "col", "edges")
    lty <- getRenderPar(g, "lty", "edges")
    lwd <- getRenderPar(g, "lwd", "edges")
    cex <- getRenderPar(g, "cex", "edges")
    
    ## set the arrow size
    minDim <- min(rw + lw, height)
    arrowLen <- par("pin")[1] / diff(par("usr")[1:2]) * minDim / pi

    ## plot the edge splines
    for (i in seq_along(splines))
    {
        suppressWarnings(renderSpline(splines[[i]],
                                      head = arrowhead[i],
                                      tail = arrowtail[i],
                                      len = arrowLen,
                                      col = col[i], lty = lty[i], lwd = lwd[i]))
    }

    ## draw text labels
    text(labelX, labelY, label, col = textCol, cex = cex)
}



## render graph to plotting device
setGeneric("renderGraph",
           function(x, ...) standardGeneric("renderGraph"))

setMethod("renderGraph", "graph",
          function(x, ...,
                   drawNodes = "renderNodes",
                   drawEdges = renderEdges,
                   graph.pars=list())
      {

          old.pars <- graph.par(graph.pars)
          on.exit(graph.par(old.pars))
          laidout <- getRenderPar(x, "laidout", "graph")
          bbox <- getRenderPar(x, "bbox", "graph")
          if(!laidout)
              stop("Graph has not been laid out yet. Please use function 'layoutGraph'")
          plot.new()

          ## eliminate all plot borders
          sub <-  getRenderPar(x, "sub", "graph")
          main <- getRenderPar(x, "main", "graph")
          old.mai <- par(mai=0.01+c(0.83*(!is.null(sub)), 0, 0.83*(!is.null(main)), 0))
          on.exit(par(mai=old.mai), add=TRUE)

          ## Set up the plot region.  We need
          ## to emulate what happens in 'plot.default' as
          ## we called plot.new() above, and for the same
          ## reasons as doing that, calling 'plot' now
          ## will mung up the thing if people are using
          ## 'layout' with this.

          ## !! Currently hardcoding log & asp,
          ## !! probably want to change that over time.
          plot.window(xlim = bbox[,1],
                      ylim = bbox[,2],
                      log="", asp=NA)

          ## Add title if necessary
          cex.main <- getRenderPar(x, "cex.main", "graph")
          cex.sub <- getRenderPar(x, "cex.sub", "graph")
          col.main <- getRenderPar(x, "col.main", "graph")
          col.sub <- getRenderPar(x, "col.sub", "graph")
          if(!is.null(sub)||!is.null(main))
              title(main, sub, cex.main=cex.main, col.main=col.main,
                    cex.sub=cex.sub, col.sub=col.sub)
          
          ## Draw Nodes, using default vectorized function or a node-by-node user-defined
          ## function   
          if(is.character(drawNodes)){
                  if(match.arg(drawNodes)=="renderNodes")
                    renderNodes(x)
              }else  drawNodes(x)


          ## Draw edges
          drawEdges(x)

          return(invisible(x))
      })










#############################################################################
##---------------------------------------------------------------------------
#############################################################################
## THE ATTIC
#############################################################################
##---------------------------------------------------------------------------
#############################################################################


## This function draws the node and edge labels on the plotting device.
## It is called by myDrawAgNode. The input is again a list of nodeData## as well as the x and y location of the nodes.
## FIXME: This doesn't have to be called every time by myDrawAgNode. It could be
## a vectorized version of text that gets called after the node plotting.
myDrawTxtLabel <- function(attr, xLoc, yLoc) {
  txt <- attr[[myAtt("label")]]

  if(length(txt)>1) stop("label must have length 1.")

  if(length(txt)==0 || txt=="") return(invisible(NULL))

  if(xor(missing(xLoc), missing(yLoc)))
    stop("'xLoc' and 'yLoc' must be either be both specified or both missing.")
  ## When there's no x location it is computed according to the adjustment
  if(missing(xLoc)) {
    lj <- attr[[myAtt("labelJust")]]
    if(length(lj)){
      justMod <- switch(lj,
                        "l" = 0,
                        "n" = -0.5,
                        "r" = -1)
      xLoc <-   as.numeric(attr[[myAtt("labelX")]]) +(justMod * as.numeric(attr[[myAtt("labelWidth")]]))
      yLoc <-  as.numeric(attr[[myAtt("labelY")]])
    }else{
      xLoc <- yLoc <- 0
    }
  }
  ## NOTE: labelFontsize is translated into cex parameter: fontsize 14 = cex 1
  text(xLoc, yLoc, txt, col=attr[[myAtt("fontcolor")]],
       cex=as.numeric(attr[[myAtt("fontsize")]])/14)
}
