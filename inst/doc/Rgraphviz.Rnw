%
% NOTE -- ONLY EDIT Rgraphviz.Rnw!!!
% Biobase.tex file will get overwritten.
%
%\VignetteIndexEntry{HOWTO Rendering}
%\VignetteDepends{Rgraphviz, graph}
%\VignetteKeywords{tools, graphs}
%\VignettePackage{Rgraphviz}

\documentclass{article}
\usepackage{hyperref}

\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Robject}[1]{{\textit{#1}}}

\author{Jeff Gentry}
\begin{document}
\title{HowTo Render A Graph Using Rgraphviz}
\maketitle

\section{Overview}
This article will demonstrate how to easily render a graph from R into
various formats using the \Rpackage{Rgraphviz}.  To do this,
first we need to generate a R graph using the \Rpackage{graph} package:

<<createGraph>>=
library(Rgraphviz)
set.seed(123)
V <- letters[1:10]
M <- 1:4
g1 <- randomGraph(V, M, .2)
g1
@

\section{Plotting in R Using Different Layout Methods}

It is quite simple to generate a R plot window to display your graph.
Once you have your graph object, simply use the \Rfunction{plot}
method:

<<plotDot, fig=TRUE, echo=FALSE>>=
    z <- plot(g1)
@       

The \Rpackage{Rgraphviz} package allows you to specify varying layout
engines, such as "dot" (the default), "neato", and "twopi".  This can
be done using the call to \Rfunction{plot}:

<<plotNeato, fig=TRUE>>=
z <- plot(g1, "neato")
@

The "twopi" layout method requires a graph to be fully connected.  
To determine if your graph is fully connected:

<<connected>>=
isConnected(g1)
@

A working "twopi" layout can be seen with this graph:
<<workingTwopi, fig=TRUE>>=
set.seed(123)
V <- letters[14:22]
g2 <- randomEGraph(V, .2)
isConnected(g2)
z <- plot(g2,"twopi")
@

And finally, to demonstrate how the differing layout methods work on
this second graph:
<<g2dot, fig=TRUE>>=
z <- plot(g2,"dot")
@
<<g2neato, fig=TRUE>>=
z <- plot(g2,"neato")
@

\section{SubGraphs}

Rgraphviz supports the ability to define specific clustering of
nodes.  This will instruct the layout algorithm to attempt to keep the
clustered nodes close together.  To do this, one must first generate
the desired set (one or more) of subgraphs with the \Robject{graph}
object.

<<getSubgraphs>>=
sg1 <- subGraph(c("a","d","j","i"), g1)
sg1
sg2 <- subGraph(c("b","e","h"), g1)
sg2
sg3 <- subGraph(c("c","f","g"), g1)
sg3
@

To plot using the subgraphs, one must use the \Rfunction{subGList}
argument which accepts a list of every subgraph.

<<subGplot, fig=TRUE>>=
plot(g1, subGList=list(sg1, sg2, sg3))
@

To demonstrate the differences that will appear with different
subgraph patterns, another example is provided:

<<subGPlot2, fig=TRUE>>=
sg1 <- subGraph(c("a","c","d","e","j"), g1)
sg2 <- subGraph(c("f","h","i"), g1)
plot(g1, subGList=list(sg1, sg2))
@

\section{Attributes}

\section{The Attributes List}

There are many visualization options in Graphviz that can be set beyond those
which are given explicit options using Rgraphviz - such as colors of
nodes and edges, which node to center on for twopi plots, node labels,
edge labels, edge weights, arrow heads and tails, etc.  A list of all
available attributes is accessible online at:
http://www.research.att.com/~erg/graphviz/info/attrs.html".  (Note
that there are some differences between default values and also some
attributes will not have an effect in Rgraphviz.  Please see the man
page for \Rfunction{graphvizAttributes} for more details)

Attributes can be set both globally (for the entire graph, for all
edges, all nodes, etc) as well as on a per-node and per-edge basis.
Global attributes are set via a list and passed in as the
\Robject{attrs} argument to \Rfunction{plot}.  A default set of global
attributes are used if nothing else is provided, using the function
\Rfunction{getDefaultAttrs} - users are encouraged to work off of the
return of this function instead of creating their own from scratch as
then attributes which they don't want to change from the defaults will
still be kept intact.  The \Rfunction{getDefaultAttrs} function takes
as a parameter the layout type to be used (dot, neato or twopi) but
defaults to dot.  The \Robject{attrs} list is a four element list
with element names of 'graph', 'cluster', 'edge' and 'node'.  Within
each element is another list, where the names correspond to attributes
and the values correspond to the value to use globally on that
attribute.  An example of this structure can be seen with the default
list provided by \Rfunction{getDefaultAttrs}:

<<defAttrs>>=
z <- getDefaultAttrs()
z
@

Users can also set attributes per-node and per-edge.  In this case, if
an attribute is defined for a particular node then that node uses the
specified attribute and the rest of the nodes use the global default.
Note that any attribute that is set on a per-node or per-edge basis
\texttt{must} have a default set globally, due to the way that
Graphviz sets attributes.  Both the per-node and per-edge attributes
are set in the same basic manner - the attributes are set using a list
where the names of the elements are the attributes, and each element
contains a named vector.  The names of this vector correspond to
either node names or edge names, and the values of the vector are the
values to set the attribute to for that node or edge.  The one place
to take care about is with the edge names in that the name of an edge
is x~y where x is the 'from' node and y is the 'to' node.  Note that
even with an undirected graph that x~y is not the same thing as y~x as
it depends on how the edge was explicitly defined.  These lists are
then passed in to \Rfunction{plot} as the arguments \Robject{nodeAttrs}
and \Robject{edgeAttrs}.  The following sections will demonstrate how to
set per-node and per-edge attributes for commonly desired tasks.  For
these we will construct two lists, \Robject{nAttrs} and \Robject{eAttrs}
to pass in to \Rfunction{plot}.

<<baseLists>>=
nAttrs <- list()
eAttrs <- list()
@

\section{Labels}

By default, nodes use the node name as their label and edges do not
have a label.  However, both can have custom labels supplied via
attributes.  

<<labels, fig=TRUE>>=
nAttrs$label <- c("lab1", "lab2", "lab3")
names(nAttrs$label) <- c("a", "b", "g")

eAttrs$label <- c("test", "test2")
names(eAttrs$label) <- c("a~h", "h~c")

plot(g1, nodeAttrs=nAttrs, edgeAttrs=eAttrs)
@

\section{Adding Some Color}

There are many areas where color can be specified to the plotted
graph.  Edges can be drawn in a non-default color, as can nodes.
Nodes can also have a specific \Robject{fillcolor} defined, detailing
what color the interior of the node should be.  The color used for the
labels can also be specified with the \Robject{fontcolor} attribute.  

<<colors, fig=TRUE>>=
## Specify node drawing color
nAttrs$color <- c("red", "red", "green", "blue")
names(nAttrs$color) <- c("a", "b", "g", "d")

## Specify edge drawing color
eAttrs$color <- c("blue", "purple")
names(eAttrs$color) <- c("a~d", "h~c")

## Specify node fill color
nAttrs$fillcolor <- "yellow"
names(nAttrs$fillcolor) <- "j"

## label color
nAttrs$fontcolor <- c("green", "red")
names(nAttrs$fontcolor) <- c("e", "f")

eAttrs$fontcolor <- c("green", "brown")
names(eAttrs$fontcolor) <- c("a~h", "h~c")

plot(g1, nodeAttrs=nAttrs, edgeAttrs=eAttrs)
@

\section{Example Graphs}

Here are some other examples of graphs that can be drawn:

Unix history, using "dot" and "neato" layouts ...

<<unixHistory,fig=TRUE>>=
z <- new("graphNEL", nodes=c("5th Edition","6th Edition","Interdata",
"7th Edition", "V7M", "8th Edition", "1 BSD", "2 BSD", "2.8 BSD",
"32V", "3 BSD", "4 BSD", "4.1 BSD", "4.2 BSD", "PWB 1.0", "USG 1.0", 
"CB Unix 1", "CB Unix 2", "CB Unix 3", "USG 2.0", "USG 3.0", 
"PWB 2.0", "Unix/TS 1.0", "Unix/TS 3.0", "Unix/TS++",  
"TS 4.0", "System V.0", "System V.2", "LSX", "Mini Unix",
"Wollongong", "Ultrix-11", "Xenix", "UniPlus+", "9th Edition", 
"2.9 BSD", "Ultrix-32", "PDP-11 Sys V", "System V.3","4.3 BSD",
"PWB 1.2"), edgeL=list(
"5th Edition"=list(edges=c(2,15)), 
"6th Edition"=list(edges=c(29,7,30,31,3)),
"Interdata"=list(edges=c(24,22,4)), 
"7th Edition"=list(edges=c(6,10,5,32,33,34)), "V7M"=list(edges=32),
"8th Edition"=list(edges=35), "1 BSD"=list(edges=8), 
"2 BSD"=list(edges=9), "2.8 BSD"=list(edges=c(32,36)),
"32V"=list(edges=11), "3 BSD"=list(edges=12), "4 BSD"=list(edges=13),
"4.1 BSD"=list(edges=c(14,9,6)), "4.2 BSD"=list(edges=c(40,37)),
"PWB 1.0"=list(edges=c(41, 16)), "PWB 1.2"=list(edges=22),
"USG 1.0"=list(edges=c(17, 20)), "CB Unix 1"=list(edges=18),
"CB Unix 2"=list(edges=19), "CB Unix 3"=list(edges=c(25,38)),
"USG 2.0"=list(edges=21), "USG 3.0"=list(edges=24), 
"PWB 2.0"=list(edges=24), "Unix/TS 1.0"=list(edges=24),
"Unix/TS 3.0"=list(edges=26), "Unix/TS++"=list(edges=26),
"TS 4.0"=list(edges=27),
"System V.0"=list(edges=28), "System V.2"=list(edges=39),
LSX=character(),  "Mini Unix"=character(), "Wollongong"=character(),
"Ultrix-11"=character(), "Xenix"=character(), "UniPlus+"=character(),
"9th Edition"=character(), "2.9 BSD"=character(),
"Ultrix-32"=character(), "PDP-11 Sys V"=character(), 
"System V.3"=character(), "4.3 BSD"=character()),
edgemode="directed")
a <- plot(z,nodeCols=c("orange","yellow"))
a <- plot(z,"neato",nodeCols=c("lightblue","yellow","lightgreen","orange"))
@

OS process map, using "twopi" layout and setting the \Robject{root}
attribute to change the center node of the "twopi" layout:
<<OSneato, fig=TRUE>>=
z <- new("graphNEL",
nodes=c("run","intr","runbl","kernel","zombie","sleep","runmem","swap","runswap","new"),
edgeL=list("run"=list(edges=c(2,3,4)),"intr"=list(edges=c(1,3)),
"runbl"=list(edges=c(1,2)), "kernel"=list(edges=c(1,5,6,7)),
"zombie"=list(edges=4),
"sleep"=list(edges=c(4,7,8)), "runmem"=list(edges=c(4,6,9,10)),
"swap"=list(edges=c(6,9)),
"runswap"=list(edges=c(7,8,10)), "new"=list(edges=c(7,9))))

curAttrs <- getDefaultAttrs("twopi")
curAttrs$graph$root <- "runmem"
a <- plot(z, "twopi", attrs=curAttrs)
@

\end{document}
